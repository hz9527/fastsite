### 基本原理及设计
vue ssr主要是使用同一套代码实现服务端渲染与客户端渲染，俗称同构渲染  
**如何实现同构渲染？**  
我们可以简单理解为，服务端渲染一套纯字符串html（不带有逻辑，如事件绑定等），再由客户端渲染。即我们在服务端有一次渲染，这一次的工作是将一个空的html模版，渲染成具有内容的html文件，吐到客户端，客户端先加载head，下载css等，再加载body，渲染我们在服务端渲染的html结构，展示一个静态html，然后下载js。js下载完毕，我们写的js代码才开始接管页面，再一次渲染（在prod下会忽略首次渲染，由于响应式数据，会进行diff，dev下，如果不同会再渲染一次）、绑定事件等  

那么这样的逻辑带来几个问题  
1. 数据同步问题，我们在服务端取的数据如果与客户端渲染时数据不同就会使得客户端在js接管页面时闪一下，并且两次渲染结果不同。`vue-server-renderer`为我们提供了`context`选项，其`state`属性会以`window.___INITIAL_STATE__`添加到返回的html中
2. 生命周期问题，由于服务端渲染也会执行我们写的vue文件，会触发created，beforeCreate等钩子，所以在这些地方不能使用BOM API
3. 实例问题，由于服务端需要处理不同客户端的请求，如果使用同一个vue（vuex，router）实例会使得整个体系乱套，所以根vue、router、vuex都需要使用工厂函数包装，保证每次都是不同实例
4. 服务端对应用的路由处理问题，由于我们一般都是单页应用，所以路由控制是由客户端处理的，对于客户端一个请求，服务端都应该返回同一个应用，所以在服务端需要手动push一个匹配到的路由
5. 请求数据时机问题，在之前基本是在create钩子中请求异步数据，但是由于服务端与客户端使用同一套代码，如果是这样处理异步数据带来的问题已经不是两次渲染结果不同，而是数据库会重复取两次数据的问题了
